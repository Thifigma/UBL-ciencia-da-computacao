\documentclass[12pt, onecolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage[top=2cm, bottom=2cm, right=2cm, left=2cm]{geometry}


\usepackage{graphicx}
\usepackage{natbib}


	\title{Circuitos Digitais}
	\author{Thiago Figueiredo Marcos}
	\date{\today}

\begin{document}
	
	\maketitle

	\section{Introdução}
	Um computador digital pode ser descrito como aquilo que computa, ou aquilo 
	que processa informação digital. A informação que é processada por um circuito 
	digital é aquela que é \textbf{quantizada} ou \textbf{discretada} \citep{art1}.\\
	\\
	No mundo comum, as informações são analógicas, ou seja, a onda que representa 
	aquela informação possui uma gama de valores diferenciados. Já os sinais digitais
	podem ser representados apenas por dois valores, ou seja, uma lógica binária.\citep{bk1}\\ 
	\\
	Os circuitos digitais são construidos por componentes eletrônicos e tem como
	entradas e saidas sinais digitais. Para usarmos informações do mundo analógico
	é preciso discretar essas informações, afím de convertelas à binária e geralmente é
	usado uma medida em Volts para determinar se uma informação é ligada ou desligada. 
	Após convertida a informação e processada no circuito digital é preciso converter
	o sinal de saída do circuito que é digital, em analógico novamente.\citep{art2}

	\section{Conversão Analógico - Digital (Discretação)}
	Sinais discretos são frequências descontinuas no tempo, ou seja, definida apenas
	para determinados instantes. Representa aproximadamente o mundo real, entretanto,
	podem ser utilizadas várias técnicas para melhorar a representação, como as de 
	processamento de sinais digitais.\\
	\\
	Aqui também vale ressaltar que o processo de discretação de alguma informação
	está consequentemente ligada a perca de determinadas informações.
		
		\subsection{Principais propiedades da discretação}
		\begin{enumerate}
			\item\textbf{Amostragem}: Discretação do sinal analógico no tempo.
			\item\textbf{Quantização}: Discretação da amplitude do sinal amsotrado 
				em niveis.
			\item\textbf{Codificação}: Atribuição de códigos, onde geralmente 
				são binários às	amplitudes do sinal quantizado.
		\end{enumerate}

	\section{Conversão Digital - Analógico (Linearização)}
	Se refere a o processo que transforma um sinal modelado por eventos discretos
	em um sinal contínuo, ou seja, o processo de integração de vários sinais discretos
	para simular um evento contínuo.

	\section{Processamento}
	O processamento de informação se refere a diversas operaçõs realizadas por um circuito
	digital para transformar a entrada de dados em uma saida significativa de interesse. 
	Isso pode ser calculos, manipular dados como agregação, separação e classificação 
	ou ainda filragem, entre outros. Além disso, no circuito digital é simplificado o 
	armazenamento de informações bem como possui uma menor probabilidade de interferências.
	
	\section{Sistemas de numeração}
	Número nos remete a ideia de quantidade, já o numeral é a representação desta 
	ideia, na prática, nos referimos a palavra número para qualquer tipo de
	representação numeral.\\
	\\
	\textbf{Exemplo}: A quantidade \textbf{Quarenta e dois} é representada pelo
	numeral 42.\\
	\\
	Sem o conhecimento da organização posicional dos números, como podemos
	representar todos eles? Poderiamos pensar em um simbolo para cada número,
	porém, existe uma infinidade de quantidades.\\
	\\
	Há cerca de 3.000 anos atrás os \textbf{Egípcios} desenvolveram um sistema
	de numeração, entre esse sistema esta a base 10, na qual utilizamos até hoje.
	Os números representados por hieróglifos eram mais usados em monumentos e 
	templos, pintados ou talhados em pedra. 
	Há sete símbolos, representando os números 1, 10, 100, 1000, 10 000, 
	100 000 e 1 000 000.\citep{art3}\\
	\\
	Algarismos é um conjunto finito de símbolos numéricos que usamos para
	representar quantidades reais. Todo e qualquer número pode ser representado
	por uma combinação de algarismos, os mais conhecidos são os indo-arábicos:
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9.\\
	\\
	Sistema de numeração é a forma de atribuir uma representação única para cada
	número. O sistema de numeração posicional atribui valor ao algarismo conforme
	a sua posição, mais a esquerda ou mais a direita.
	\\
	No sistema decimal de numeração posicional possuimos 10 algarismos, 0 .. 9,
	um cada um deles representa seu valor absoluto, ou seja, o valor 0 representa
	o nada, o valor 1 representa uma única unidade e assim por diante. Dependendo
	da posição que o valor estiver, seu valor absoluto pode variar, por exemplo:
	Imagine um número com 4 casas decimais, - - - -, o número que estiver na 
	"casa" mais a esquerda não representara seu valor absoluto e sim o seu valor
	absoluto multiplicado por um milhão.\\
	\\
	\textbf{Exemplo}: 4237 = 4*1000 + 2*100 + 3*10 + 7*1, observe o seguinte:\\
	\\
	4*1000 	= 4.000\\
	2*100 	= 200\\
	3*10	= 30\\
	7*1	= 7\\
	\\
	A soma de todos os valores resulta no valor original 4237.\\
	\\
	Agora podemos sistematizar isso matematicamente, sabemos que um número
	inteiro A no sistema decimal é presentado por N digitos assim:\\
	\begin{center}
		$A_{n-1} A_{n-2} ... A_{n2} A_{n1} A_{n0}$
	\end{center}
	Cada $a_{i}$ é um algarismo decimal.

	\begin{center}
		$a_{n-1}*10^{n-1} + a_{n-2}*10^{n-2}+ ... + 
		a_{2}*100 + a_{1} * 10 + a_{0} * 1$
	\end{center}

	ou seja,

	\begin{center}
		$\sum_{i = 0}^{n - 1} a_{i} * 10^{i}$
	\end{center}

	Usando a mesma lógica, podemos representar os números racionais no sistema
	decimal
	
	\begin{center}
		$\sum_{i = 0}^{n - 1} a_{i} * 10^{i} + 
		\sum_{i = 1}^{\infty} a_{-i} * 10^{-i}$
	\end{center}

	\section{Truncamento}
	Vemos que à medida que caminhamos mais a direita depois da virgula, o
	valor relativo a cada algarismo se torna cada vez menor, podemos
	fazer uma representação aproximada do número gerado, limitando 
	o número de algarismos após a vírgula por uma constante \texttt{M}.\\
	\\
	Essa aproximação chama-se truncamento. Com o truncamento há também
	um erro de aproximaçaõ que pode ser obtido com a diferença do número original
	com o número truncado.\\
	\\
	Ao truncarmos um número com uma constante \texttt{M} para qualquer 
	número real com n algarismos à esquerda da virgula, 
	e \texttt{M} algarismos à direita, assim: 

	\begin{center}
		$a_{n-1} a_{n-2} ... a_{1} a_{0}, a_{-1} a_{-2} ... a_{M}$
	\end{center}

	então temos que o erro de aproximação de qualquer número N será:

	\begin{center}
		$\texttt{err} < 10^{-M}$
	\end{center}
	
	ou seja, aumentar \texttt{M} implica em diminuir o erro.
	
	\section{Bases não decimais}
	A quantidade de algarismos usados em um sistema de numeração posicional é
	chama de base, por exemplo: O sistema decimal tem 10, o sistema binário tem 2 e 
	assim por diante.\\
	\\
	Acima fizemos uma representação matemática dos números posicionais 
	racionais, a questão é que, em um sistema posicional em uma determinada
	base \textbf{d}, pode ser representada da seguinte forma: 

	\begin{center}
		$\sum_{i=0}^{n-1} a_{i} * d^{i} + 
		\sum_{i=1}^{\infty} a_{-i} * d^{-i}$
	\end{center}

	Para indicar a base em que um número esta representado é comum a 
	seguinte notação:

	\begin{center}
		$(a_{n-1} a_{n-2} ... a_{1} a_{0}, a_{-1} a_{-2} ... a_{M})_d$
	\end{center}

	\section{Conversão de bases}
	Para converter um número $\textbf{n}_{10}$ para $\textbf{n}_{d}$ faremos
	divisões sucessivas entre o quociente e a base \textbf{d}.\\
	\\
	Existem algumas conversões que são triviais de realizar, como por exemplo
	da base 2 para base 16, ou ainda, da base 10 \texttt{(até o 15)} 
	para base 16.\\
	\\
	Da base 2 para base 16 por exemplo, pode se seguir o padrão de contagem 
	de 4 em 4 bits e ver qual a representação.
	
	\section{Operações Binárias}
	A base 2 é a base númerica mais utilizada na computação hoje em dia, em conjunto
	com a base 8, 16 e 64. Veremos futuramente que o computador realiza operações
	aritméticas na sua Unidade Lógica Aritmética \texttt{(ULA)}, entenderemos
	agora como essas operações são realizadas na base binária.

	\subsection{soma}
	Antes de falarmos sobre a soma binária, precisamos relembrar o algoritmo da
	soma decimal, considere dois numeros A e B, sendo eles:\\
	\\
	A = $a_{n-1} a_{n-2} ... a_1 a_0$\\
	B = $b_{n-1} b_{n-2} ... b_1 b_0$\\
	\\
	O resultado da soma de A com B:\\
	\\
	C = $c_n c_{n-1} c_{n-2} ... c_{1} c_{0}$ com n + 1 algarismos.\\
	\\
	O mesmo método se aplica a somas binárias, exemplificado abaixo:
	\begin{table}[h]
		\begin{tabular}{|c|c|c|c|}
			\hline
			x & Y & Resultado & Vai um \\ \hline
			0 & 0 & 0 & 0 \\ \hline
			0 & 1 & 1 & 0 \\ \hline
			1 & 0 & 1 & 0 \\ \hline
			1 & 1 & 1 & 1 \\ \hline
		\end{tabular}
	\end{table}
	
	\subsection{Overflow}
	Agora considere a seguinte soma, $(111001)_2 + (110011)_2 = (1101100)_2$ 
	repare que a soma de dois números binários de 6 bits, resultou em um número
	binário de 7 bits, se nossa memoria fosse apenas de 6 bits, ocasionária um 
	\texttt{overflow}.\\
	\\
	Há também a possibilidade de fazer a representação em uma quantidade maior de
	bits, basta adicionar o zero a esquerda do número e ter memória suficiente 
	para a representação.

	\subsection{Subtração}
	Para realizar as subtrações binárias, usaremos o complemento de 1 e complemento
	de 2, para evitar, detalhamentos adicionais.\\
	\\
	\textbf{Complemento de 1}: O complemento de 1, basicamente, é o processo
	de inversão do bit, se for 1 fica 0 e vise versa.\\
	\\
	\textbf{Complemento de 2}: É o complemento de 1 de uma sequência de bit,
	adicionando uma unidade ao final, exemplificando:
	
	\begin{description}
		\item[$\bar{B}$]: Complemento de 1
		\item[$\bar{B} + 1$]: Complemento de 2
	\end{description}

	\subsection{Multiplicação}
	O algoritmo da multiplicação binária é semelhante a ídeia usada no decimal, 
	e muito mais facil, pois os operandos é somente 0 e 1.\\
	\\
	Observe que se A tem \texttt{n} algarismos e B tem \texttt{m} algarismos
	o produto $A * B$ terá no máximo, \texttt{n} + \texttt{m} algarismos.
	
	\subsection{Números Reais}
	Como fica as operações nos números reais? como sempre, podemos nos inspirar na
	base decimal, suponha os seguintes números: \\
	\\
	A = $a_{n-1} a_{n-2} ... a_1 a_0, a_{-1} ... a_{-k}$\\
	B = $b_{n-2} b_{n-2} ... b_1 b_0, b_{-1} ... b_{-k}$\\
	\\
	se $a_{-k} \ne b_{-k}$, ou seja, se os valores depois da virgual de \texttt{a} 
	forem diferentes da virgula de \texttt{b}. Na soma, subtração, e multiplicação
	podemos	inicialmente ignorar a virgula, realizar a operação, logo em seguida, 
	realocar a virgula \texttt{k} algarismos à direita.

	\section{Representações númericas em computador digital}
	Em um computador digital, quaquer informação (dados), em última instância
	é representado por um número. Atualmente os números são representados em base 2
	pela facilidade em fazer contas. Um computador digital possui espaço finito
	para guardar informações e o processamento dessas informações é feito em grupos
	de bits em vez de bit a bit, para uma melhor eficiência.\\
	\\
	Como o processamento desses dados(informações) é feito em grupos de bits, damos
	um nome a esse grupo, que é chamado de \texttt{palavra de dado}, trata-se de uma
	sequência de bits de tamanho fixo que é processada em conjunto. Uma palavra
	por exemplo pode ter 16 bits ou 8 bits, depende...\\
	\\
	Um conjunto de 8 bits é chamado de 1 byte, com essa relação explicita de 
	1 byte sendo 8 bits. Um sistema digital, pode padronizar o tamanho de suas 
	\texttt{palavras}(operandos). Os mais comuns hoje são os processadores de 
	64 bits	ou ainda os mais antigos de 32 bits, isso significa que na 
	Unidade Lógica Aritmética \texttt{(ULA)} dentro do processador, 
	os operandos podem ter no máximo 64 bits, ou 32 bits depende da arquitetura. 
	veremos isso mais profundamente no futuro.\\

	\subsection{Estudos de melhoria de processamento de dados}
	Hoje existem pesquisadores tentando melhorar a capacidade de processamento, 
	na computação clássica, uma melhor capacidade de processamento seria uma palavra
	maior ou ainda o processamento paralelo de palavras. Existe a computação
	quântica, que utiliza a sobreposição de estados nas particulas atômicas para
	definir 0 ou 1, ou ainda os 2 ao mesmo tempo, gerando uma especie de 
	processamento paralelo bem avançado, porém, probabilistico. 
	Existem outros malucos, em outras áreas que pretendem futuramente 
	usar sistemas orgânicos para realizar o processamento de informações. 
	A melhora da capacidade de processamento dos dados na éra da informação 
	é uma quebra de barreiras e uma evidente elevação da fronteira do conhecimento.
	\\
	\section{Representação Binária}
	Podemos sistematizar a representação de números inteiros com \texttt{N} bits
	da seguinte forma: $2^{n} - 1$. \\
	\\
	\textbf{Exemplo}: Com 3 bits podemos representar $2^{3} - 1$ números inteiros.
			\begin{center} 
				$2^{3} - 1 = 7$ \\
			\end{center}
	Com esta sistematização podemos prever o próximo número e os anteriores, 
	da seguinte forma: \\
	\\
	O número atual é $2^{n} - 1$ o próximo seria: $2^{n}$, logo, o anterior
	do atual é $2^{n} - 2$.

	\section{Extenções}
	Imagine a seguinte situação, um número \texttt{A} com \texttt{n} bits, porém,
	queremos fazer uma representação com \texttt{w} bits sendo \texttt{w > n}.\\
	\\
	Se o número for um inteiro sem sinal, neste caso, basta adicionar os zeros
	a esquerda até \texttt{n} ficar igual a \texttt{w}.
	
		\subsection{Números com sinais}
	Para fazermos representações de números negativos, precisamos reservar um espaço
	na palavra para representar o sinal. Existem várias técnicas para fazer esta 
	representação, como o sinal-magnitude, complementos de 1 e de 2, veremos
	adiante.

		\subsubsection{Sinal-Magnitude}
	O Sinal-Magnitude é a reserva do bit mais significativo da palavra, ou seja, 
	o bit mais a esquerda, para representar o sinal do número: \\
	\\
	O sinal \textbf{+} é representado pelo bit: 0\\
	O sinal \textbf{-} é representado pelo bit: 1\\
	\\
	\texttt{Exemplo}: A = ${_0^1}\;a_{n-2}\;a_{n-3}\;...\;a_1\;a_0$
	
	Agora imagine que o bit $_0^1$ é o bit de sinal, e queremos fazer a
	extensão da palavra. Neste caso nós conservamos o bit mais
	significativo mais a esquerda e acrescentamos com os zeros a esquerda.\\
	\\
	\texttt{Exemplo}: A = $(a_{n-1} a_{n-2} ... a_2 a_1 a_0)_2$, temos aqui
	uma palavra de \texttt{n} bits, e queremos extender para \texttt{w} bits
	sendo $\texttt{w} > \texttt{n}$\\
	\\
	logo, temos o seguinte: 
	A = $(a_{n-1}\;0\;0\;0\;0\;...\;k\;a_{n-2}\;...\;a_2\;a_1\;a_0)_2$\\
	\\
	Essa técnica vale para qualquer sinal, seja positivo ou negativo.
	
		\subsubsection{Inclusões de sinais}
	A inclusão de sinal trata-se de uma forma simples de converter uma 
	representação binária sem sinal para uma representação com sinal e 
	para realizar a conversão basta converter os níveis lógicos do número:\\
	\\
	\texttt{Exemplo}: Converter o número $2 - (\bar{0}10)$, aqui, vale ressaltar
	que o bit destacado é a representação do sinal, neste caso, temos um 2 
	positivo. Para termos o 2 negativo, invertemos os valores, ou seja: 
	$101$. Ou seja, basta tirar o complemento de 1 da palavra. \\
	\\
	Palavra (010) $->$ Complemento de 1 $->$ (101), isso vale para qualquer número,
	inclusive o zero.\\
	\\
	Deve-se tomar o devido cuidado quando for realizar operações com o 
	complemento de 1, pode gerar confusões no percurso, por isso, vamos
	exemplificar: \\
	\\
	Vamos considerar a seguinte subtração: (3 - 2)\\
	\\
	A = 3 = 011, aqui o bit 0 significa que o númeoro é positivo.\\
	B = 2 = 010.\\
	Tiramos o complemento de 1 do número B = 010\\
	B = 2 = 010 = $(101)_c1$\\
	\\
	Agora sim, podemos fazer a soma A + (-B), ou seja: $011 - 101$\\
	Inicialmente a conta parece não fazer muito sentido, porém, 
	lembre-se que deve adicionar 1 no resultado da soma.\\
	\\	
	Usar o complemento de 1 para fazer a representações de sinais
	se torna problemática, pois haverá duas representações para o
	númeor zero, repare que temos o zero positivo: 000 e o
	zero negativo: 111. Ter duas representações para um mesmo
	número é algo que gera certo desconforto, por este motivo
	é mais saudável aos olhos e um alívio a maquina usar o 
	complemento de 2.\\
	\\
	As vantagens de se usar o complemento de 2 para representar os
	sinais é que teremos a representação de mais 1 número e também
	evitaremos duas representações para o número zero.\\
	\\
	As relações ficam da seguinte forma, para uma palavra de 3 bits.\\
	\\
	A - 000 = $0_{10}$\\
	B - 001 = $+1_{10}$\\
	C - 010 = $+2_{10}$\\
	D - 011 = $+3_{10}$\\
	\\
	\texttt{Complemento de 2}\\
	\\
	A - 111 = $-1_{10}$\\
	B - 110 = $-2_{10}$\\
	C - 101 = $-3_{10}$\\
	D - 100 = $-4_{10}$\\
	\\
	Apenas para enfatizar a diferença entre C1 e C2, deixo
	abaixo como fica C1:\\
	\\
	\texttt{Complemento de 1}\\
	A - 111 = $-0_{10}$\\
	B - 110 = $-1_{10}$\\ 	
	C - 101 = $-2_{10}$\\ 	
	D - 100 = $-3_{10}$\\
	\\
	Observe que se a palavra estiver em representação de 
	complemento de 2, devemos ignorar o primeiro digito
	mais significativo, pois este indica o sinal,
	devemos lembrar também que caso um número seja
	negativo, deve-se primeiro fazer a conversão 
	para complemento de dois para depois trocar a base, 
	isto é fundamental!\\
	\\
	Umas das problemáticas para nós humanos é a comparação.
	Repare que $(001_2)_{c2} > (101_2)_{c2}$ não é nada
	intuitivo, porém, para o computador é indiferente.


	% Referências. 

	\bibliographystyle{apalike}
        \bibliography{ref.bib}

\end{document}
